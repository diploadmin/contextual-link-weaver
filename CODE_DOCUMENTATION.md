# Contextual Link Weaver — Code Documentation

This document provides a detailed walkthrough of the plugin's source code: how each file works, the data flow between components, and the design decisions behind the implementation.

---

## Table of Contents

- [File Overview](#file-overview)
- [includes/gemini-api.php — LLM Abstraction Layer](#includesgemini-apiphp--llm-abstraction-layer)
- [contextual-link-weaver.php — Main Plugin File](#contextual-link-weaverphp--main-plugin-file)
  - [Settings Registration](#settings-registration)
  - [Settings Page Rendering](#settings-page-rendering)
  - [Editor Asset Loading](#editor-asset-loading)
  - [REST API Endpoints](#rest-api-endpoints)
  - [Handler: /suggestions (Full Post Scan)](#handler-suggestions-full-post-scan)
  - [Handler: /link-for-text (Selection-Based LLM)](#handler-link-for-text-selection-based-llm)
  - [Handler: /link-from-rag (RAG Source Discovery)](#handler-link-from-rag-rag-source-discovery)
- [src/index.js — Gutenberg Editor UI](#srcindexjs--gutenberg-editor-ui)
  - [Format Type (Toolbar Button)](#format-type-toolbar-button)
  - [Popover — Parallel Query Architecture](#popover--parallel-query-architecture)
  - [Plugin Sidebar (Full Post Scan)](#plugin-sidebar-full-post-scan)
  - [handleInsertLink — Block Manipulation](#handleinsertlink--block-manipulation)

---

## File Overview

```
contextual-link-weaver/
├── contextual-link-weaver.php     Main plugin: settings, REST routes, handlers
├── includes/
│   └── gemini-api.php             LLM provider abstraction (Gemini + OpenAI)
├── src/
│   └── index.js                   Gutenberg React UI (source)
├── build/
│   ├── index.js                   Compiled/minified JS (auto-generated)
│   └── index.asset.php            Dependency manifest (auto-generated)
└── package.json                   Build tooling config (@wordpress/scripts)
```

The `build/` directory is generated by `npm run build` (via `@wordpress/scripts`) and should not be edited manually. The `src/index.js` is the sole JS source file.

---

## includes/gemini-api.php — LLM Abstraction Layer

This file provides a single entry point function that routes prompts to the active LLM provider.

### Provider Router

```php
function clw_get_linking_suggestions( $prompt_text )
```

Reads the `clw_llm_provider` WordPress option (`'gemini'` or `'local'`) and delegates to the appropriate backend function. All REST handlers call this function — they never call a provider directly.

### Google Gemini Provider

```php
function clw_call_gemini( $prompt_text )
```

**Endpoint:** `POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent`

**Key details:**
- API key is passed as a URL query parameter (`?key=...`), not in a header
- Uses `generationConfig.responseMimeType: "application/json"` to force Gemini to return clean JSON without Markdown code fences
- Response is navigated as: `candidates[0].content.parts[0].text` → JSON string → `json_decode()`

**Request body structure:**
```json
{
  "contents": [{ "role": "user", "parts": [{ "text": "<prompt>" }] }],
  "generationConfig": { "responseMimeType": "application/json" }
}
```

### OpenAI-Compatible Provider

```php
function clw_call_openai_compatible( $prompt_text )
```

**Endpoint:** `POST {base_url}/chat/completions`

**Key details:**
- Auth via `Authorization: Bearer {key}` header (omitted if key is empty)
- Uses `response_format: { type: "json_object" }` to force JSON output
- The `json_object` mode requires the model to return a JSON **object** (not array), which is why all prompts request `{"suggestions": [...]}` instead of a bare `[...]`
- Response path: `choices[0].message.content` → JSON string → `json_decode()`

**Request body structure:**
```json
{
  "model": "openai/gpt-oss-20b",
  "messages": [{ "role": "user", "content": "<prompt>" }],
  "response_format": { "type": "json_object" }
}
```

### Double-Decode Pattern

Both providers share a "double-decode" pattern:

1. **First decode:** `json_decode()` on the HTTP response body → gives the provider's envelope (with `candidates` or `choices`)
2. **Extract text:** Navigate the envelope to get the LLM's generated text string
3. **Second decode:** `json_decode()` on the generated text → gives the actual suggestions array

This is necessary because the LLM's output is a JSON string embedded within the provider's JSON response.

---

## contextual-link-weaver.php — Main Plugin File

### Settings Registration

```php
function clw_settings_init()
```

Registers six options in the `clw_settings_group` via the WordPress Settings API:

| Option | Type | Purpose |
|---|---|---|
| `clw_llm_provider` | `'gemini'` or `'local'` | Which LLM backend to use |
| `clw_gemini_api_key` | string | Google AI Studio API key |
| `clw_llm_url` | string | Base URL for OpenAI-compatible endpoint |
| `clw_llm_model` | string | Model identifier |
| `clw_llm_key` | string | Bearer token |
| `clw_rag_api_url` | string | Chatbot API base URL for RAG |

All options are sanitized with `sanitize_text_field` and stored in the `wp_options` table.

### Settings Page Rendering

```php
function clw_settings_page_html()
```

Uses a **custom layout** rather than `do_settings_sections()`. This is because the Gemini and Local sections need to be wrapped in `<div>` elements with IDs (`clw-gemini-section`, `clw-local-section`) for JavaScript-driven show/hide toggling.

**Provider toggle logic:**

```php
function clw_provider_field_callback()
```

Renders a `<select>` dropdown with an inline `<script>` block. The `clwToggleSections()` JavaScript function:
1. Gets references to both section `<div>` elements by ID
2. Shows the one matching the selected provider, hides the other
3. Runs on `DOMContentLoaded` to set initial state based on stored option
4. Runs on `onchange` for instant feedback (no page reload needed)

The RAG section is always visible because it's independent of the LLM provider choice.

### Editor Asset Loading

```php
function clw_enqueue_editor_assets()
```

Hooked to `enqueue_block_editor_assets` — only fires inside the Gutenberg editor, not on the frontend or in the classic editor.

Reads `build/index.asset.php` (auto-generated by `@wordpress/scripts`) which declares:
- `dependencies` — WordPress packages the script needs (e.g., `wp-element`, `wp-components`, `wp-api-fetch`)
- `version` — content hash for cache busting

### REST API Endpoints

```php
function clw_register_rest_route()
```

Registers three POST routes under the `contextual-link-weaver/v1` namespace. All share a single permission callback requiring `edit_posts` capability.

| Route | Handler | Called by |
|---|---|---|
| `/suggestions` | `clw_handle_suggestions_request` | Sidebar "Scan Post & Generate" button |
| `/link-for-text` | `clw_handle_link_for_text_request` | Toolbar button (LLM query) |
| `/link-from-rag` | `clw_handle_link_from_rag_request` | Toolbar button (RAG query) |

### Handler: /suggestions (Full Post Scan)

**Data flow:**

```
Editor sidebar
    ↓ POST { content, post_id }
clw_handle_suggestions_request()
    ├── 1. get_posts() → all published posts (excluding current)
    ├── 2. Build $post_list array: [{ id, title, url }, ...]
    ├── 3. Construct prompt with post_list JSON + post content
    ├── 4. clw_get_linking_suggestions($prompt) → LLM call
    ├── 5. Unwrap {"suggestions": [...]} envelope
    ├── 6. For each suggestion: match post_id_to_link → enrich with title/url
    └── 7. Return enriched array
```

**Prompt rules enforced by the LLM:**
1. `anchor_text` must exist **verbatim** in the draft (no paraphrasing)
2. Must be 4-6 words long
3. Must be a natural-sounding phrase
4. Up to 5 suggestions maximum
5. Cannot use an article title unless it appears in the draft

**Why `{"suggestions": []}` instead of `[]`?**

The OpenAI `json_object` response format requires the model to return a JSON object (not a bare array). Gemini can handle both, but for consistency across providers, the prompt always requests the object-wrapped format. The handler unwraps it:

```php
if ( isset( $suggestions_from_api['suggestions'] ) ) {
    $suggestions_from_api = $suggestions_from_api['suggestions'];
}
```

### Handler: /link-for-text (Selection-Based LLM)

**Key difference from /suggestions:** The anchor text is already known (user selected it), so the LLM only needs to **rank posts by relevance** — no phrase discovery needed. This makes the prompt simpler and the response faster.

**Data flow:**

```
Toolbar popover
    ↓ POST { anchor_text, post_id }
clw_handle_link_for_text_request()
    ├── 1. get_posts() → all published posts, keyed by ID for O(1) lookup
    ├── 2. Construct ranking prompt with anchor_text + post list
    ├── 3. clw_get_linking_suggestions($prompt) → LLM call
    ├── 4. Unwrap suggestions envelope
    ├── 5. For each: validate post_id exists, enrich with title/url
    └── 6. Return array of { post_id, title, url, reasoning }
```

**Post list keying:** Unlike /suggestions which uses a flat array, this handler keys the post list by ID (`$post_list[$post->ID]`). This allows O(1) lookup when enriching LLM results, instead of a nested loop.

### Handler: /link-from-rag (RAG Source Discovery)

**Two-step external API protocol:**

```
Toolbar popover
    ↓ POST { query }
clw_handle_link_from_rag_request()
    ├── Step 1: POST /api/conversation/get_id → fresh conversation_id
    ├── Step 2: POST /api/chat/{conversation_id} → query + get sources
    ├── 3. Extract sources[] from response
    ├── 4. Deduplicate by base URL (same page may appear multiple times)
    ├── 5. Prefer deep_link_url over plain url (includes highlight params)
    ├── 6. Truncate text snippets to 200 chars
    └── 7. Return top 5 as [{ title, url, text }]
```

**Why a fresh conversation_id each time?** The chatbot API is designed for multi-turn conversations. Each conversation has server-side state (MongoDB). Using a fresh ID ensures clean context without prior conversation history influencing results.

**Deep link URLs:** The chatbot API returns `deep_link_url` fields that include query parameters like `?diplo-hl-id=abc123`. When the user clicks such a link, JavaScript on the target page highlights the relevant passage. This is more useful than plain URLs because it takes the reader directly to the matching content.

**Deduplication logic:** The chatbot may return multiple chunks from the same page (different paragraphs). We deduplicate by `$source['url']` (the base page URL, not the deep link) to avoid showing the same page multiple times. The first occurrence's deep_link_url is kept.

---

## src/index.js — Gutenberg Editor UI

### Format Type (Toolbar Button)

```js
registerFormatType( 'contextual-link-weaver/suggest', {
    tagName:   'span',
    className: 'clw-suggestion',
    edit:      LinkWeaverInlineButton,
} );
```

**Why `tagName: 'span'` instead of `'a'`?**

The built-in `core/link` format already owns the `<a>` tag. Registering another format type with `tagName: 'a'` would conflict and the button wouldn't appear. Using `<span>` with a unique className avoids this. The actual link insertion is done via `applyFormat()` with `type: 'core/link'`, which is the correct way to create links in Gutenberg.

**Why `BlockControls` instead of `RichTextToolbarButton`?**

`RichTextToolbarButton` places buttons in the **inline formatting dropdown** (the "more" menu). `BlockControls` with `group="other"` places the button directly in the **block toolbar** — more visible and accessible. The button uses the `"superhero"` dashicon.

### Popover — Parallel Query Architecture

When the user clicks the toolbar button, two independent API calls fire simultaneously:

```
handleClick()
    ├── apiFetch('/link-for-text')  → setLlmResults() / setLlmError()
    └── apiFetch('/link-from-rag')  → setRagResults() / setRagError()
```

Each has its own loading/results/error state. The Popover renders both sections immediately — as each response arrives, its section updates independently. This means:

- RAG results (~12s) appear while LLM is still processing
- If one fails, the other still shows results
- The Popover is never fully "empty loading" for very long

**Link insertion via `applyFormat()`:**

```js
onChange( applyFormat( value, {
    type: 'core/link',
    attributes: { href: url, url },
} ) );
```

This is the standard Gutenberg rich-text API for applying a format. It wraps the currently selected text range (`value.start` to `value.end`) in a `core/link` format, which renders as an `<a>` tag. This is equivalent to what happens when a user manually adds a link via the built-in link popover.

### Plugin Sidebar (Full Post Scan)

```js
registerPlugin( 'link-weaver-plugin', { render: LinkWeaverSidebar } );
```

Registers a sidebar panel accessible from the Gutenberg "More tools & options" menu (three dots → Link Weaver). Uses `PluginSidebar` from `@wordpress/edit-post`.

**State management:** Uses local `useState` hooks — no Redux store needed because the state is ephemeral (only exists while the sidebar is open).

**Data sources via `useSelect`:**
- `core/editor → getEditedPostContent()` — full post HTML including unsaved changes
- `core/editor → getCurrentPostId()` — to exclude the current post from suggestions
- `core/block-editor → getBlocks()` — full block tree, needed for link insertion

### handleInsertLink — Block Manipulation

This function handles the complex task of inserting a link into existing block content from the sidebar. It can't use `applyFormat()` because there's no active text selection — the sidebar knows the anchor text string but not its position in the rich-text value.

**Strategy:**

```
handleInsertLink(anchorText, url)
    ├── 1. Walk all blocks via blocks.map()
    ├── 2. For each block, extract content (string or originalHTML)
    ├── 3. Check if content includes anchorText
    ├── 4. If found: string.replace() with <a> tag (first occurrence only)
    ├── 5. Track the block's clientId for scrolling
    ├── 6. Create MutationObserver on .editor-styles-wrapper
    ├── 7. Call replaceBlocks() to commit the change
    ├── 8. Observer fires when DOM updates:
    │       ├── Find block by data-block attribute
    │       ├── scrollIntoView({ behavior: 'smooth', block: 'center' })
    │       ├── Find the <a class="clw-inserted-link"> element
    │       ├── Swap class to "clw-highlight-link" (for visual feedback)
    │       └── Disconnect observer (one-shot)
    └── 9. Remove the accepted suggestion from sidebar list
```

**Why MutationObserver?**

`replaceBlocks()` is asynchronous — the DOM doesn't update immediately. A `MutationObserver` watches for child node changes in the editor wrapper, fires when the updated block renders, then scrolls and highlights. It disconnects itself after the first match to avoid memory leaks.

**CSS class lifecycle:**
1. Link is inserted with `class="clw-inserted-link"` (used as a DOM query selector)
2. Once found in the DOM, the class is swapped to `"clw-highlight-link"` (for styling)
3. The `clw-inserted-link` class is removed to prevent double-matching

**Content extraction handles two formats:**
- **String:** `block.attributes.content` is a plain string (most common)
- **Object:** `block.attributes.content.originalHTML` — some blocks store content as a RichText value object. The `originalHTML` property contains the raw HTML string.
